<!DOCTYPE html>
<html>
  <head>
    <title>Spreader</title>
    <style>
      body {
        align-self: stretch;
        display: flex;
        flex-direction: column;
        height: 100vh;
        margin: 0;
      }

      .reader-container {
        background-color: #eee;
        display: flex;
        flex: 1;
        justify-content: center;
        overflow: hidden;
        position: relative;
      }

      .reader-doc {
        color: #000;
        color: transparent;
        font-size: 8px;
        line-height: 1;
        overflow-y:  auto;
        position: relative;
        width: 100%;
      }


      .reader-doc-word .reader-orp {
        color: transparent;
      }

      .reader-doc::-webkit-scrollbar {
        background-color: transparent;
        width: 5px;
      }

      .reader-doc::-webkit-scrollbar-thumb {
        background-color: #aaa;
      }

      .reader-doc-page {
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        margin: 200px auto 100px auto;
        padding: 16px;
        width: 300px;
      }

      .reader-doc-paragraph {
        display: flex;
        flex-flow: row wrap;
        margin: 8px;
      }


      .reader-doc-word {
        background-color: #ccc;
        border-radius: 1em;
        margin: 2px;
        padding: 0 4px;
      }

      .reader-doc-paragraph .reader-doc-word:first-child {
        margin-left: 30px;
      }

      .reader-orp {
        color: #f00;
      }

      .reader-read {
        background-color: #333;
      }

      .reader-box {
        background-color: #fff;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        height: 60px;
        position: absolute;
        top: 60px;
        transform: translateY(-50%);
        width: 350px;
      }

      .reader-box::after {
        position: absolute;
        content: '';
        width: 4px;
        height: 100%;
        left: calc(50% - 2px);
        right: 0;
        background: linear-gradient(#ddd, #fff 30%, #fff 70%, #ddd);
        z-index: -1;
      }

      .reader-box-container {
        position: relative;
      }

      .reader-box-msg {
        font-size: 30px;
        position: absolute;
        top: 30px;
        transform: translateY(-50%);
      }

      .reader-box-pointer {
        color: #f00;
        position: absolute;
        text-align: center;
        top: 170px;
        transform: translate(-50%, -1em);
        transition: left .1s ease, top .1s ease;
      }
    </style>
  </head>
  <body>
    <script>
      var potter = `He was in trouble now and he knew it. He would have to face his
aunt and uncle later and pay the price for his rudeness, but he did not
care very much just at the moment; he had much more pressing matters
on his mind.
Harry was sure that the cracking noise had been made by someone
Apparating or Disapparating. It was exactly the sound Dobby the
house-elf made when he vanished into thin air. Was it possible that
Dobby was here in Privet Drive? Could Dobby be following him right
at this very moment? As this thought occurred he wheeled around and
stared back down Privet Drive, but it appeared to be completely deserted
again and Harry was sure that Dobby did not know how to
become invisible`;

      const SIMILAR_RATIO = 1/8;
      const $ = document.querySelector.bind(document);

      // Calculate the optimal recognition point of a word
      function optimalRecognitionPoint(word) {
        let length = word.length;
        while('\n,.?!:;"'.indexOf(word[--length]) !== -1);
        switch(++length) {
          case 0: case 1: return 0;
          case 2: case 3: return 1;
          default: return Math.floor(length / 2 - length / 6);
        }
      }

      // Return the number of time arr appears in a string
      function strNumInstances(str, arr) {
        return arr
          .map(x => (str.match(new RegExp(x, 'g')) || []).length) // count instances
          .reduce((a, b) => a+b); // Sum instances
      }

      function wordSimilarCharRatio(word) {
        // Characters that look similar
        let offenders = [
          ['m', 'rn', 'n'],
          ['cl', 'ci', 'd'],
          ['vv', 'w', 'uu,'],
          ['u', 'v'],
          ['l', 'i'],
          ['i', 'j'],
          ['j', 'l,'],
          ['h', 'k'],
          ['p', 'q', 'b', 'd'],
          ['s', 'z'],
          ['t', 'f'],
          ['O', 'Q'],
          ['L', 'J'],
          ['E', 'F'],
          ['S', 'Z'],
          ['B', 'P'],
        ];

        let numOffenders = offenders
          .map(off => strNumInstances(word, off)) // Count number of each offender
          .reduce((a, b) => a+b); // Sum them

        return 1 - Math.min(numOffenders, 10) / 10 * SIMILAR_RATIO;
      }

      // Read words of length 4-7 faster than 0.9
      function wordLengthRatio(word) {
        return word.length < 4 || word.length > 7 ? 1 : 0.97;
      }

      // Word speed ratio based on punctuation
      function wordPunctuationRatio(word) {
        let lastChar = word.slice(-1);
        // How much slower a word should be based on each punctuation mark
        let punctuationRatios = {
          '.': 0.4,
          '?': 0.5,
          '!': 0.5,
          ',': 0.5,
          ';': 0.6,
          ':': 0.6,
        };
        return punctuationRatios[lastChar] || 1;
      }

      // Calculates the word speed ratio of a word
      function wordSpeedRatio(word) {
        return wordLengthRatio(word) * wordPunctuationRatio(word) * wordSimilarCharRatio(word);
      }

      // Creates an XSS safe element given a tag name, props, and its content
      function makeElem(tag, props, ...content) {        
        let s = document.createElement(tag);

        // Content is a string
        if(content.length === 1 && typeof content[0] === 'string') {
          s.innerText = content[0];

        // Content is an array
        } else {
          content.forEach(elem => elem && s.appendChild(elem));
        }

        // Add all the props to the span
        for(let key in props) {
          s.setAttribute(key, props[key]);
        }

        return s;
      }

      // Creates a span for a word and splits it based on its ORP
      function orpSpan(word) {
        let orp = optimalRecognitionPoint(word);
        return makeElem('span', {class: 'reader-word'},
          makeElem('span', {}, word.slice(0, orp)),
          makeElem('span', {class: 'reader-orp'}, word[orp]),
          makeElem('span', {}, word.slice(orp+1)),
        );
      }

      // Takes some text, splits it up into word objects
      function parseText(text) {
        let words = text
          .split(/\s+|\n/g)
          .map(w => ({
            word: w,
            ratio: wordSpeedRatio(w),
            orp: optimalRecognitionPoint(w),
            html: orpSpan(w),
          }));
        return words;
      }

      // Destination scroll position of document
      let goalDocScroll = 0;

      // identifier for requested animation frame
      let frameReq;

      // Animated smooth scrolling
      function scrollToPos() {
        const doc = $('.reader-doc');
        doc.scrollTop += (goalDocScroll - doc.scrollTop) * 0.2;
        if(Math.abs(doc.scrollTop - goalDocScroll) < 1) {
          doc.scrollTop = goalDocScroll;
          frameReq = undefined;
          return;
        }
        frameReq = requestAnimationFrame(scrollToPos);
      }

      // Moves the pointer to the specified elem
      function movePointer(word) {
        const pointer = $('#readerPointer');
        const doc = $('.reader-doc');
        const box = $('.reader-box');
        const msg = $('.reader-box-msg');
        /*
          Aligning the pointer
        */
        let {x, y, width, height} = word.elem.getElementsByClassName('reader-orp')[0].getBoundingClientRect();
        let {x: offX, y: offY, height: docHeight} = doc.getBoundingClientRect();
        let {top: top, height: pageHeight} = $('.reader-doc-page').getBoundingClientRect();
        let {y: pointerY, height: pointerHeight} = pointer.getBoundingClientRect();

        if(!word.elem.className.match(/reader-read/))
          word.elem.className += ' reader-read';

        // Calculate y position of pointer
        if(document.body.clientHeight >= doc.scrollHeight || doc.scrollHeight <= doc.scrollTop + docHeight) {
          pointer.style.top = (y + offY + height/2 + pointerHeight) + 'px';
        } else {
          pointer.style.top = '30px';
          goalDocScroll = doc.scrollTop + y - pointerY + height / 2 + offY;
          if(frameReq)
            cancelAnimationFrame(frameReq);
          frameReq = requestAnimationFrame(scrollToPos);
        }

        // calculate x position of pointer
        pointer.style.left = (x - offX + width/2) + 'px';

        /*
          Updating the word box
        */
        msg.removeChild($('.reader-box-msg').firstChild);
        msg.appendChild(word.html);
        // Reset msg position
        msg.style.left = '0px';

        // Get position of the orp in the word
        let {x: orpX, width: orpWidth} = word.html.getElementsByClassName('reader-orp')[0].getBoundingClientRect();
        let {x: msgX, width: msgWidth} = $('.reader-box-container').getBoundingClientRect();

        // Set the msg x offset to the center of the orp
        msg.style.left = (msgX - orpX - orpWidth / 2 + msgWidth / 2) + 'px';
      }

      let reader;

      // Creates the speedreader dom
      function createSpeedReader(text) {
        let paragraphs = text.map(parseText);
        let i = 0;
        let paragraphIndex = 0;
        let container = makeElem('div', {class: 'reader-container'}, 
          makeElem('div', {class: 'reader-doc'},
            makeElem('div', {class: 'reader-doc-page'},
              ...paragraphs.map((words, p) =>
                makeElem('div', {class: 'reader-doc-paragraph'},
                  ...words.map(w => {
                    const index = i;
                    w.index = i++;
                    w.paragraph = p;
                    w.elem = makeElem('span', {class: 'reader-doc-word'}, orpSpan(w.word));
                    w.elem.addEventListener('click', () => {movePointer(w); reader.index = index;}, false);
                    return w.elem;
                  }),
                ),
              ),
            ),
          ),
          makeElem('div', {class: 'reader-box-pointer', id: 'readerPointer'}, String.fromCharCode(9650)),
          makeElem('div', {class: 'reader-box'},
            makeElem('span', {class: 'reader-box-container'},
              makeElem('span', {class: 'reader-box-msg'}, 'Press Right Arrow Key!'),
            )
          ),
        );
        let words = [].concat(...paragraphs);
        return {
          container,
          words,
          length: words.length,
          index: 0,
        };
      }
      reader = createSpeedReader([potter, potter, potter]);
      document.body.appendChild(reader.container);
      movePointer(reader.words[0]);
      const wpm = 600;
      let charTimeout;
      let keys = {};
      let dir = 1;
      let lastIndex = 0;

      function nextWord() {
        clearTimeout(charTimeout);
        let word = reader.words[reader.index];
        movePointer(word);
        reader.index = Math.max(Math.min(reader.index + dir, reader.length-1), 0);
        charTimeout = setTimeout(nextWord, 60000 / wpm / word.ratio);
      }

      window.addEventListener('keydown', e => {
        let {code} = e;
        if(keys[code])
          return;

        keys[code] = true;
        switch(code) {
          case 'ArrowLeft':
            dir = -1;
            lastIndex = reader.index;
            break;
          case 'ArrowRight':
            lastIndex = reader.index;
            dir = 1;
            break;
        }
        if(dir !== 0) {
          nextWord();
        }
      }, false);
      window.addEventListener('keyup', e => {
        let {code} = e;
        keys[code] = false;

        switch(code) {
          case 'ArrowLeft':
            if(keys.ArrowRight) {
              dir = 1;
            } else {
              if(reader.index === lastIndex + dir)
                nextWord();
              reader.index = Math.max(Math.min(reader.index - dir, reader.length), 0);
              dir = 0;
            }
            break;
          case 'ArrowRight':
            if(keys.ArrowLeft) {
              dir = -1;
            } else {
              if(reader.index === lastIndex + dir)
                nextWord();
              reader.index = Math.max(Math.min(reader.index - dir, reader.length), 0);
              dir = 0;
            }
            break;
        }
        if(dir === 0) {
          clearTimeout(charTimeout);
        }
      }, false);
    </script>
  </body>
</html>