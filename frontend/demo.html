<!DOCTYPE html>
<html>
  <head>
    <title>Spreader</title>
    <style>
      body {
        margin: 0;
      }
      .reader-container {
        position: relative;
        background-color: #eee;
        margin: auto;
        width: 500px;
        display: flex;
        justify-content: center;
        height: 200px;
        overflow: hidden;
      }

      .reader-doc {
        font-size: 8px;
        line-height: 1;
        padding: 8px;
        width: 100%;
        color: #000;
        color: transparent;
        overflow-y:  auto;
        position: relative;
      }


      .reader-doc-word .reader-orp {
        color: transparent;
      }

      .reader-doc::-webkit-scrollbar {
        background-color: transparent;
        width: 5px;
      }

      .reader-doc::-webkit-scrollbar-thumb {
        background-color: #aaa;
      }

      .reader-doc-body {
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-flow: row wrap;
        margin: 50px auto 150px auto;
        padding: 8px;
        width: 300px;
      }

      .reader-doc-word {
        /*background-color: #333;*/
        background-color: #ccc;
        border-radius: 1em;
        margin: 2px;
        padding: 0 2px;
      }

      .reader-orp {
        color: #f00;
      }

      .reader-read {
        background-color: #333;
      }

      .reader-box {
        background-color: #fff;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        position: absolute;
        display: flex;
        flex-direction: column;
        top: 50%;
        transform: translateY(-50%);
        width: 350px;
        height: 30px;
      }

      .reader-box-container {
        position: relative;
      }

      .reader-box-msg {
        position: absolute;
        top: 15px;
        transform: translateY(-50%);
      }

      .reader-box-pointer {
        color: #f00;
        text-align: center;
        position: absolute;
        top: calc(50%);
        transform: translate(-50%, -2em);
        transition: left .1s ease;
      }
    </style>
  </head>
  <body>
    <script>
      var potter = `He was in trouble now and he knew it. He would have to face his
aunt and uncle later and pay the price for his rudeness, but he did not
care very much just at the moment; he had much more pressing matters
on his mind.
Harry was sure that the cracking noise had been made by someone
Apparating or Disapparating. It was exactly the sound Dobby the
house-elf made when he vanished into thin air. Was it possible that
Dobby was here in Privet Drive? Could Dobby be following him right
at this very moment? As this thought occurred he wheeled around and
stared back down Privet Drive, but it appeared to be completely deserted
again and Harry was sure that Dobby did not know how to
become invisible`;

      const SIMILAR_RATIO = 1/8;
      const $ = document.querySelector.bind(document);

      // Calculate the optimal recognition point of a word
      function optimalRecognitionPoint(word) {
        let length = word.length;
        while('\n,.?!:;"'.indexOf(word[--length]) !== -1);
        switch(++length) {
          case 0: case 1: return 0;
          case 2: case 3: return 1;
          default: return Math.floor(length / 2 - length / 6);
        }
      }

      // Return the number of time arr appears in a string
      function strNumInstances(str, arr) {
        return arr
          .map(x => (str.match(new RegExp(x, 'g')) || []).length) // count instances
          .reduce((a, b) => a+b); // Sum instances
      }

      function wordSimilarCharRatio(word) {
        // Characters that look similar
        let offenders = [
          ['m', 'rn', 'n'],
          ['cl', 'ci', 'd'],
          ['vv', 'w', 'uu,'],
          ['u', 'v'],
          ['l', 'i'],
          ['i', 'j'],
          ['j', 'l,'],
          ['h', 'k'],
          ['p', 'q', 'b', 'd'],
          ['s', 'z'],
          ['t', 'f'],
          ['O', 'Q'],
          ['L', 'J'],
          ['E', 'F'],
          ['S', 'Z'],
          ['B', 'P'],
        ];

        let numOffenders = offenders
          .map(off => strNumInstances(word, off)) // Count number of each offender
          .reduce((a, b) => a+b); // Sum them

        return 1 - Math.min(numOffenders, 10) / 10 * SIMILAR_RATIO;
      }

      // Read words of length 4-7 faster than 0.9
      function wordLengthRatio(word) {
        return word.length < 4 || word.length > 7 ? 1 : 0.97;
      }

      // Word speed ratio based on punctuation
      function wordPunctuationRatio(word) {
        let lastChar = word.slice(-1);
        // How much slower a word should be based on each punctuation mark
        let punctuationRatios = {
          '.': 0.5,
          '?': 0.6,
          '!': 0.6,
          ',': 0.7,
          ';': 0.7,
          ':': 0.7,
        };
        return punctuationRatios[lastChar] || 1;
      }

      // Calculates the word speed ratio of a word
      function wordSpeedRatio(word) {
        return wordLengthRatio(word) * wordPunctuationRatio(word) * wordSimilarCharRatio(word);
      }

      // Creates an XSS safe element given a tag name, props, and its content
      function makeElem(tag, props, ...content) {        
        let s = document.createElement(tag);

        // Content is a string
        if(content.length === 1 && typeof content[0] === 'string') {
          s.innerText = content[0];

        // Content is an array
        } else {
          content.forEach(elem => elem && s.appendChild(elem));
        }

        // Add all the props to the span
        for(let key in props) {
          s.setAttribute(key, props[key]);
        }

        return s;
      }

      // Creates a span for a word and splits it based on its ORP
      function orpSpan(word) {
        let orp = optimalRecognitionPoint(word);
        return makeElem('span', {class: 'reader-word'},
          makeElem('span', {}, word.slice(0, orp)),
          makeElem('span', {class: 'reader-orp'}, word[orp]),
          makeElem('span', {}, word.slice(orp+1)),
        );
      }

      // Takes some text, splits it up into word objects
      function parseText(text) {
        let words = text
          .split(/\s+|\n/g)
          .map(w => ({
            word: w,
            ratio: wordSpeedRatio(w),
            orp: optimalRecognitionPoint(w),
            html: orpSpan(w),
          }));
        return words;
      }

      // Moves the pointer to the specified elem
      function movePointer(word) {
        const pointer = $('#readerPointer');
        const doc = $('.reader-doc');

        /*
          Aligning the pointer
        */
        let {x, y, width, height} = word.elem.getElementsByClassName('reader-orp')[0].getBoundingClientRect();
        let {x: offX, y: offY} = doc.getBoundingClientRect();
        let {top: top} = $('.reader-doc-body').getBoundingClientRect();

        if(!word.elem.className.match(/reader-read/))
          word.elem.className += ' reader-read';

        // Calculate y position of pointer
        doc.scrollTop = y - offY - top - height;

        // calculate x position of pointer
        pointer.style.left = (x - offX + width/2) + 'px';

        /*
          Updating the word box
        */
        let msg = $('.reader-box-msg');
        msg.removeChild($('.reader-box-msg').firstChild);
        msg.appendChild(word.html);
        // Reset msg position
        msg.style.left = '0px';

        // Get position of the orp in the word
        let {x: orpX, width: orpWidth} = word.html.getElementsByClassName('reader-orp')[0].getBoundingClientRect();
        let {x: msgX, width: msgWidth} = $('.reader-box-container').getBoundingClientRect();

        // Set the msg x offset to the center of the orp
        msg.style.left = (msgX - orpX - orpWidth / 2 + msgWidth / 2) + 'px';
      }

      let reader;

      // Creates the speedreader dom
      function createSpeedReader(text) {
        let words = parseText(text);
        let container = makeElem('div', {class: 'reader-container'}, 
          makeElem('div', {class: 'reader-doc'},
            makeElem('div', {class: 'reader-doc-body'},
              ...words.map((w, i) => {
                w.elem = makeElem('span', {class: 'reader-doc-word'}, orpSpan(w.word));
                w.elem.addEventListener('click', () => {movePointer(w); reader.index = i;}, false);
                return w.elem;
              })
            ),
          ),
          makeElem('div', {class: 'reader-box-pointer', id: 'readerPointer'}, String.fromCharCode(9650)),
          makeElem('div', {class: 'reader-box'},
            makeElem('span', {class: 'reader-box-container'},
              makeElem('span', {class: 'reader-box-msg'}, 'Press Right Arrow Key!'),
            )
          ),
        );
        return {
          container,
          words,
          length: words.length,
          index: 0,
        };
      }
      reader = createSpeedReader(potter + potter);
      document.body.appendChild(reader.container);
      movePointer(reader.words[0]);
      const wpm = 450;
      let charTimeout;
      let keys = {};
      let dir = 1;
      let lastIndex = 0;

      function nextWord() {
        clearTimeout(charTimeout);
        let word = reader.words[reader.index];
        movePointer(word);
        reader.index = Math.max(Math.min(reader.index + dir, reader.length), 0);
        charTimeout = setTimeout(nextWord, 60000 / wpm / word.ratio);
      }

      window.addEventListener('keydown', e => {
        let {code} = e;
        if(keys[code])
          return;

        keys[code] = true;
        switch(code) {
          case 'ArrowLeft':
            dir = -1;
            lastIndex = reader.index;
            break;
          case 'ArrowRight':
            lastIndex = reader.index;
            dir = 1;
            break;
        }
        if(dir !== 0) {
          nextWord();
        }
      }, false);
      window.addEventListener('keyup', e => {
        let {code} = e;
        keys[code] = false;

        switch(code) {
          case 'ArrowLeft':
            if(keys.ArrowRight) {
              dir = 1;
            } else {
              if(reader.index === lastIndex + dir)
                nextWord();
              reader.index = Math.max(Math.min(reader.index - dir, reader.length), 0);
              dir = 0;
            }
            break;
          case 'ArrowRight':
            if(keys.ArrowLeft) {
              dir = -1;
            } else {
              if(reader.index === lastIndex + dir)
                nextWord();
              reader.index = Math.max(Math.min(reader.index - dir, reader.length), 0);
              dir = 0;
            }
            break;
        }
        if(dir === 0) {
          clearTimeout(charTimeout);
        }
      }, false);
    </script>
  </body>
</html>